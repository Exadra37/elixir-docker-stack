#!/bin/bash

# @link https://elixir-lang.org/getting-started/debugging.html
# @link https://s3.us-east-2.amazonaws.com/ferd.erlang-in-anger/text.v1.1.0.pdf

set -eu

Show_Help()
{
  cat << HEREDOC

  ELIXIR DOCKER DEV STACK

  A docker developemnt stack that includes Elixir, Phoenix, Erlang, Oberver and Postgres.


  Elixir CLI Usage:

    elixir [options] [.exs file] [data]


  Elixir Docker Stack Usage:

    elixir [options] [command] [args]


  Elixir Docker Stack Options:

    -d, --detached            Run the docker container detached from the terminal.

    --db, --database          Starts the container with the Postgres database up.

    --df, --dockerfile        The dockerfile to run a container.
                              Defaults to: debian .
                                $
                                $ elixir --dockerfile alpine up

    --et, --elixir-tag        The Elixir version to be used for the docker tag,
                              Defaults to the latest Elixir version: slim
                                $ elixir --elixir-tag 1.3.4:slim

    -h, --help                Shows the help for the Elixir CLI and Stack.
                                $ elixir -h
                                $ elixir --help
                                $ elixir --help stack

    -it, --interactive-tty    Run the docker container attached to the terminal.
                                $ elixir -it up

    -p, --publish             Map the host ports to the docker container ports.
                              Defaults to: 4000:4000 .
                                $ elixir --publish 8000:4000

    --pv, --phoenix-version   The Phoenix version to be installed.
                              Defaults to the last release, eg: 1.4.3 .
                                $ elixir --phoenix-version 1.3.4 up

    -u, --user                The user we want to run inside the container,
                              Defaults to current user, eg: 1000 .
                                $ elixir --user 0 shell

    --verbose <level>         Enables verbose output for the docker stack.
                              Defaults to level 0, and can go until level 4.
                                $ elixir --verbose 1 up
                                $ elixir --verbose 2 shell
                                $ elixir --verbose 3 observer
                                $ elixir --verbose 4 build


  Elixir Docker Stack Commands:

    <no-command>    Runs Elixir inside the container as it would in the host.
                      $ elixir --help

    build           Builds the docker image for the given dodkerfile.
                    Defaults to build from: debian .
                      $ elixir build
                      $ elixir build alpine

    container-logs  Shows a tail -f of the container logs.
                      $ elixir container-logs

    down            Stops and removes the running container.
                      $ elixir down

    iex             The Elixir IEx shell.
                      $ elixir iex [options] <args>

    mix             The Elixir mix tool.
                      $ elixir mix <command> [options] <args>
                      $ elixir mix help
                      $ elixir mix new elixir-project
                      $ elixir mix phx.new phoenix-app

    pgcli           A better shell for Postgres, includes uto-completion.
                      $ elixir pgcli [options] <args>

    observer        Starts the Observer GUI from an IEx shell.
                      $ elixir observer

    observer-cli    Allows to start from IEx the Observer CLI(like Linux HTOP).
                      $ elixir observer-cli

    up              Starts the Elixir docker stack.
                      $ elixir up
                      $ elixir --db up
                      $ elixir --dockerfile alpine up
                      $ elixir -it --publish 8000:4000 up
                      $ elixir --elixir-tag 1.3 --phoenix-version 1.3.4 --db up

    shell           A shell inside the container for the Elixir docker stack.
                      $ elixir shell
                      $ elixir -u 0 shell

HEREDOC

}

################################################################################
# FUNCTIONS
################################################################################

  Print_Text_With_Label()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local label_text="${1? Missing label to print!!!}"

      local text="${2? Missing text to print!!!}"

      local verbosity_print_level="${3? Missing verbosity print level!!!}"

      local label_background_color="${4:-42}"

      local text_background_color="${5:-229}"


    ############################################################################
    # EXECUTION
    ############################################################################

      case "${verbosity_print_level}" in
        "1" )
          local label_background_color="40"
          ;;
        "2" )
          local label_background_color="44"
          ;;
        "3" )
          local label_background_color="45"
          ;;
        "4" )
          local label_background_color="46"
          ;;
        * )
          local label_background_color="42"
      esac

      if [ "${verbosity_print_level}" -le "${VERBOSE_LEVEL}" ]; then
        printf "\n\e[1;${label_background_color}m ${label_text}:\e[30;48;5;${text_background_color}m ${text} \e[0m \n"
      fi
  }

  Print_Text()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local text="${1? Missing text to print!!!}"

      local verbosity_print_level="${2? Missing verbosity print level!!!}"

      local text_color="${3:-44}"


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ "${verbosity_print_level}" -le "${VERBOSE_LEVEL}" ]; then
        printf "\n\e[1;${text_color}m ${text} \e[0m \n"
      fi
  }

  Print_Fatal_Error()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local text="${1? Missing text to print for the Fatal Error!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      printf "\n\e[1;41m FATAL ERROR:\e[30;48;5;229m ${text} \e[0m \n\n"
  }

  Create_Env_File_If_Not_Exists()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local suffix="${1:-.docker-container}"

      local example_suffix="${2:--example}"


    ############################################################################
    # EXECUTION
    ############################################################################

      # Useful to pass environment variables into the container.
      if [ ! -f .env"${suffix}" ]; then
        if [ -f .env"${suffix}${example_suffix}" ]; then
          cp .env"${suffix}${example_suffix}" .env"${suffix}"
        else
          touch .env"${suffix}"
        fi
      fi
  }

  Setup_X11_Server_Display()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local host_setup_dir="${1? Missing host setup dir!!!}"

      local xauth_display="${2:-:0}"


    ############################################################################
    # VARS
    ############################################################################

      local xauth="${host_setup_dir}"/.docker.xauth


    ############################################################################
    # EXECUTION
    ############################################################################

      # @link http://wiki.ros.org/docker/Tutorials/GUI#The_isolated_way
      touch "${xauth}"
      xauth nlist "${xauth_display}" | sed -e 's/^..../ffff/' | xauth -f "${xauth}" nmerge -

      echo "${xauth}"
  }


################################################################################
# DOCKER FUNCTIONS
################################################################################

  Is_Not_Present_Docker_Image()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local _image_name="${1}"

    ############################################################################
    # EXECUTION
    ############################################################################

      [ -z $( sudo docker images -q "${_image_name}" ) ] && return 0 || return 1
  }

  Get_Container_Ip_Address()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      echo -n $( sudo docker exec -it ${container_name} sh -c 'echo -n $(hostname -i)' )
  }

  Get_Docker_Image_Tag()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local elixir_tag="${1? Missing Elixir Version!!!}"

      local phoenix_version="${2? Missing Phoenix version!!!}"

      local dockerfile="${3? Missing variant for docker image!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ "${dockerfile}" = "observer-debian" ]; then
        echo "${elixir_tag}"
      else
        echo "${elixir_tag}-${phoenix_version}-${dockerfile}"
      fi
  }

  Create_Docker_Network_If_Not_Exists()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local network_name="${1? Missing network name!!!}"

    ############################################################################
    # EXECUTION
    ############################################################################

      sudo docker network create "${network_name}" &> /dev/null || true
  }

  Create_Docker_Volume()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "CREATING DOCKER VOLUME:" "${container_name}" "2"

      sudo docker volume create "${container_name}"
  }

  Build_Docker_Image()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local dockerfile="${2? Missing variant for docker image!!!}"

      local elixir_tag="${3? Missing Elixir tag!!!}"

      local phoenix_version="${4? Missing Phoenix version!!!}"

      local phoenix_install_from="${5? Missing Phoenix install command!!!}"

      local build_path="${6? Missing build path for docker image!!!}"


    ############################################################################
    # VARS
    ############################################################################

      if [ "${dockerfile}" = "observer-debian" ]; then

        local image_name=exadra37/observer

        local elixir_tag=latest

      fi

      local tag="$( Get_Docker_Image_Tag "${elixir_tag}" "${phoenix_version}" "${dockerfile}" )"

      local docker_image="${image_name}:${tag}"

      local dockerfile_path="${build_path}"/${dockerfile}".Dockerfile"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "DOCKER IMAGE" "${docker_image}" "1"

      Print_Text_With_Label "BUILDING FROM DOCKERFILE" "${dockerfile_path}" "2"

      Print_Text_With_Label "INSTALL PHOENIX" "${phoenix_install_from}" "3"

      sudo docker build \
        --no-cache \
        --force-rm \
        --pull \
        --file "${dockerfile_path}" \
        --build-arg "ELIXIR_VERSION=${elixir_tag}" \
        --build-arg "PHOENIX_VERSION=${phoenix_version}" \
        --build-arg "PHOENIX_INSTALL_FROM=${phoenix_install_from}" \
        --tag ${docker_image} \
        "${build_path}"
  }

  Docker_Container_Is_Running()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      sudo docker container ls -a | grep -qw "${container_name}" -

      return $?
  }

  Attach_To_App_Container()
  {
    Print_Text_With_Label "FUNCTION" "Attach_To_App_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local app_container_name="${1? Missing app container name!!!}"

      local container_user="${2? Missing container user!!!}"

      local background_mode="${3? Missing backround mode to run the container!!!}"

      local run_command="${4? Missing command to run in the container!!!}"

      shift 4


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "ATTACHING TO CONTAINER" "${app_container_name}" "1"

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${@}" "2"

      Print_Text_With_Label "BACKGROUND MODE" "${background_mode}" "3"

      APP_NODE_NAME="${APP_NAME}@$( Get_Container_Ip_Address ${app_container_name} )"

      sudo docker exec \
        --user ${container_user} \
        --env "APP_NODE_NAME=${APP_NODE_NAME}" \
        --env "APP_NODE_COOKIE=${ERLANG_COOKIE}" \
        ${background_mode} \
        ${app_container_name} \
        ${run_command} ${@}
  }

  Start_Or_Attach_To_App_Container()
  {
    Print_Text_With_Label "FUNCTION" "Start_Or_Attach_To_App_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local elixir_tag="${2? Missing Elixir tag!!!}"

      local phoenix_version="${3? Missing Phoenix version!!!}"

      local dockerfile="${4? Missing docker image variant!!!}"

      local app_name="${5? Missing the APP name!!!}"

      local app_network="${6? Missing app network}"

      local app_container_name="${7? Missing app container name!!!}"

      local container_user="${8? Missing container user!!!}"

      local port_map="${9? Missing port map!!!}"

      local env_file="${10? Missing the env file!!!}"

      local background_mode="${11? Missing backround mode to run the container!!!}"

      local host_setup_dir="${12? Missing host dir for Elixir stack setup!!!}"

      local run_command="${13? Missing command to run in the container!!!}"

      shift 13


    ############################################################################
    # VARS
    ############################################################################

      local tag="$( Get_Docker_Image_Tag "${elixir_tag}" "${phoenix_version}" "${dockerfile}" )"

      local docker_image="${image_name}:${tag}"

      local xauth_sock="/tmp/.X11-unix"

      local xauth=$( Setup_X11_Server_Display "${host_setup_dir}" )


    ############################################################################
    # EXECUTION
    ############################################################################

      if Is_Not_Present_Docker_Image "${docker_image}"; then

        Print_Text_With_Label "DOCKER IMAGE" "${docker_image}" "0"

        Print_Text_With_Label "TAG" "${tag}" "0"

        Print_Text_With_Label "DOCKERFILE" "${dockerfile}" "0"

        Print_Fatal_Error "Missing docker image for >>> ${app_name} <<< APP. Build it with: elixir build ${dockerfile}"

        exit 1
      fi

      if Docker_Container_Is_Running "${app_container_name}"; then

        Attach_To_App_Container \
          "${app_container_name}" \
          "${container_user}" \
          "${background_mode}" \
          "${run_command}" \
          ${@}

        # if [ "${background_mode}" == "-it" ]; then
        #   sudo docker stop "${app_container_name}"
        # fi

        exit 0
      fi

      Print_Text_With_Label "STARTING DOCKER IMAGE" "${docker_image}" "1"

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${@}" "2"

      Print_Text_With_Label "DOCKERFILE" "${dockerfile}" "3"

      Print_Text_With_Label "TAG" "${tag}" "3"

      Print_Text_With_Label "CONTAINER USER" "${container_user}" "3"

      Print_Text_With_Label "APP NETWORK" "${app_network}" "3"

      local env_file_option=""

      if [ -f "${env_file}" ]; then
          local env_file_option="--env-file ${env_file}"
      fi

      sudo docker run \
        --rm \
        ${background_mode} \
        ${env_file_option} \
        --env "APP_NODE_NAME=${APP_NODE_NAME}" \
        --env "APP_NODE_COOKIE=${ERLANG_COOKIE}" \
        --name "${app_container_name}" \
        --user "${container_user}" \
        --network "${app_network}" \
        --publish "127.0.0.1:${port_map}" \
        --volume "${PWD}":/home/"${container_user}"/workspace \
        --volume "${app_container_name}_${tag}_var_lib_postgresql":/var/lib/postgresql \
        --volume "${app_container_name}_${tag}_var_log_postgresql":/var/log/postgresql \
        --volume "${app_container_name}_${tag}_config_sublimetext_3":/home/"${container_user}"/.config/sublime-text-3 \
        --volume="/tmp/.X11-unix":"/tmp/.X11-unix":ro \
        --volume="${xauth}":"${xauth}":ro \
        --env="XAUTHORITY=${xauth}" \
        "${docker_image}" \
        ${run_command} ${@}
  }

  Start_Dummy_App_Container()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local elixir_tag="${2? Missing Elixir tag!!!}"

      local phoenix_version="${3? Missing Phoenix version!!!}"

      local dockerfile="${4? Missing docker image variant!!!}"

      local app_name="${5? Missing the APP name!!!}"

      local app_network="${6? Missing app network}"

      local app_container_name="${7? Missing app container name!!!}"

      local container_user="${8? Missing container user!!!}"

      local port_map="${9? Missing port map!!!}"

      local env_file="${10? Missing the env file!!!}"

      local host_setup_dir="${11? Missing host dir for Elixir stack setup!!!}"

      shift 11


    ############################################################################
    # EXECUTION
    ############################################################################

      # We need a dummy Docker container running before we start any real
      # process on it, so that we can run Elixir or Phoenix apps with a full
      # qualified node name, byt getting the IP address of the dummy container.
      if ! Docker_Container_Is_Running "${app_container_name}"; then

        Print_Text "STARTING A DUMMY CONTAINER" "4"

        Start_Or_Attach_To_App_Container \
          "${image_name}" \
          "${elixir_tag}" \
          "${phoenix_version}" \
          "${dockerfile}" \
          "${app_name}" \
          "${app_network}" \
          "${app_container_name}" \
          "${container_user}" \
          "${port_map}" \
          "${env_file}" \
          "-td" \
          "${host_setup_dir}" \
          ""

          # need to give time for the container be available, before we try to
          # attach to it in the next command.
          sleep 1
    fi
  }

  Start_Database_Container()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local app_name="${1? Missing app name!!!}"

      local app_network="${2? Missing app network!!!}"

      local database_image="${3? Missing database image name!!!}"

      local database_data_dir="${4? Missing database data dir!!!}"

      local container_user="${5? Missing container user!!!}"

      local database_container_name="${6? Missing database container name!!!}"

      local background_mode="${7? Missing background mode to run the container!!!}"

      local run_command="${8? Missing command to run in the container!!!}"

      shift 8


    ############################################################################
    # EXECUTION
    ############################################################################

      mkdir -p "${database_data_dir}"

      Print_Text_With_Label "DATABASE CONTAINER" "${database_container_name}" "2"

      if Docker_Container_Is_Running "${database_container_name}"; then
        return
      fi

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${@}" "2"

      sudo docker run \
        --rm \
        --detach \
        --hostname "${app_name}_database" \
        --name "${database_container_name}" \
        --network "${app_network}" \
        --volume "${database_data_dir}":/var/lib/postgresql/data \
        "${database_image}" ${run_command} ${@}
  }

  Start_Observer_Container()
  {
    # to implement over ssh tunnel:
    #   * https://sgeos.github.io/elixir/erlang/observer/2016/09/16/elixir_erlang_running_otp_observer_remotely.html
    #   * https://github.com/Stratus3D/dotfiles/blob/master/scripts/tools/epmd_port_forwarder
    #   * https://github.com/Nebo15/k8s-utils
    #   * https://chazsconi.github.io/2017/04/22/observing-remote-elixir-docker-nodes.html
    #
    # http://jbavari.github.io/blog/2016/03/11/using-erlang-observer-on-a-remote-elixir-server/

    ############################################################################
    # INPUT
    ############################################################################

      local host_setup_dir="${1? Missing host setup dir!!!}"

      local app_name="${2? Missing app name!!!}"

      local app_network="${3? Missing app network!!!}"

      local app_container_name="${4? Missing app container_name!!!}"

      local erlang_cookie="${5? Missing the Erlang cookie!!!}"

      shift 5

      Print_Text_With_Label "HOST SETUP DIR" "${host_setup_dir}" "3"

      Print_Text_With_Label "APP NAME" "${app_name}" "3"

      Print_Text_With_Label "APP NETWORK" "${app_network}" "3"

      Print_Text_With_Label "APP CONTAINER NAME" "${app_container_name}" "3"

      Print_Text_With_Label "ERLANG COOKIE" "${erlang_cookie}" "3"

      if ! Docker_Container_Is_Running "${app_container_name}"; then
        Print_Fatal_Error "The App container >>> ${app_container_name} <<< is not running. Are you in the APP root folder?"
        return
      fi

      local app_ip_address=$( Get_Container_Ip_Address "${app_container_name}" )

      Print_Text_With_Label "APP IP ADDRESS" "${app_ip_address}" "3"

      case "${1:-}" in
        "htop" )
          local observer_command="observer-cli ${app_name} ${app_ip_address} ${erlang_cookie}"
          local observer_container_name="${app_name}_observer-htop"
          shift 1
          ;;

        "shell" )
          local observer_command="zsh"
          local observer_container_name="${app_name}_observer-shell"
          shift 1
          ;;

        "" )
          local observer_command="observer ${app_name} ${app_ip_address} ${erlang_cookie}"
          local observer_container_name="${app_name}_observer"
          ;;

        * )
          Print_Fatal_Error "Unsupported: ${input}"

      esac

    ############################################################################
    # CONSTANTS
    ############################################################################

      local OBSERVER_DOCKER_IMAGE="exadra37/observer"


    ############################################################################
    # EXECUTION
    ############################################################################

      if Is_Not_Present_Docker_Image "${OBSERVER_DOCKER_IMAGE}"; then

        Print_Text_With_Label "DOCKER IMAGE" "${OBSERVER_DOCKER_IMAGE}" "0"

        Print_Fatal_Error "Build first the docker image with: elixir build observer-debian"

        exit 1
      fi

      local xauth=$( Setup_X11_Server_Display "${host_setup_dir}" )

      Print_Text_With_Label "OBSERVER COMMAND" "${observer_command}" "2"

      sudo docker run \
        --rm \
        -it \
        --hostname "${observer_container_name}" \
        --name "${observer_container_name}" \
        --network "${app_network}" \
        --volume="/tmp/.X11-unix":"/tmp/.X11-unix":ro \
        --volume="${xauth}":"${xauth}":ro \
        --env="XAUTHORITY=${xauth}" \
        "${OBSERVER_DOCKER_IMAGE}" ${observer_command} ${@}
  }

  Stop_And_Remove_Docker_Containers()
  {
    ############################################################################
    # EXECUTION
    ############################################################################

      for container_name in "${@}"; do

        if Docker_Container_Is_Running "${container_name}" ; then

          # no need to remove the containers explicitly, once they where started
          # with the `--rm` flag
          sudo docker stop "${container_name}"
        fi

      done
  }

################################################################################
# MAIN
################################################################################

  Main()
  {
    ############################################################################
    # CONSTANTS
    ############################################################################

      # from `/home/username/developer/acme` we will get `developer/acme`
      CURRENT_PATH="${PWD#*${USER}/}"
      # from `developer/acme` we get `developer_acme`
      #APP_NAME="${CURRENT_PATH//\//_}"

      APP_NAME="${PWD##*/}"

      APP_NODE_NAME=""

      ERLANG_COOKIE="super-long-secret-cookie"


    ############################################################################
    # ENV
    ############################################################################

      local image_name=exadra37/elixir-phoenix

      local dockerfile=debian

      local elixir_tag=slim

      local phoenix_version=1.4.3

      local phoenix_command=phx.server

      local build_path=~/bin/vendor/exadra37-docker/elixir/dev-cli/docker/build

      local background_mode="-it"

      local port_map="4000:4000"

      local host_setup_dir="${PWD}"/.local

      local env_file=".env.docker-container"

      local database_image=postgres:alpine

      local database_user=root

      local database_command=postgres

      local database_data_dir="${host_setup_dir}"/postgres/data


      # We can override any of the above variables in the .elixir-docker-stack file
      #   for the current project we are working on.
      # Bear in mind that some can be override if provided as an argument or option
      #   to this bash script.
      if [ -f .elixir-docker-stack ]; then
        source .elixir-docker-stack
      fi

      phoenix_install_from="hex phx_new ${phoenix_version}"

      # from 1.4.0 assigns 1.4
      version="${phoenix_version%.*}"

      # Phoenix framework installation procedure changed from 1.4 onwards.
      if [ "${version}" \< "1.4" ]; then
        phoenix_install_from="https://github.com/phoenixframework/archives/raw/master/phx_new-${phoenix_version}.ez"
      fi

      local container_user=elixir

      #local container_name="${APP_NAME}_$( Get_Docker_Image_Tag "${elixir_tag}" "${phoenix_version}" "${dockerfile}" )"
      local app_container_name="${APP_NAME}_app"

      local VERBOSE_LEVEL=0

      local app_network=network_"${APP_NAME}"

      local database_container_name="${APP_NAME}_postgres"


    ############################################################################
    # PARSE INPUT / EXECUTION
    ############################################################################

      mkdir -p "${host_setup_dir}"

      Create_Docker_Network_If_Not_Exists "${app_network}"

      local run_command=${0##*/}

      for input in "${@}"; do
        case "${input}" in

          -d | --detached )
            background_mode="--detach"
            shift 1
            ;;

          --db | --database )
            Print_Text_With_Label "OPTION" "--db, --database" "4"

            shift 1

            # $ createdb -h postgres_video-hub -O postgres -U postgres testapp_dev
            Start_Database_Container \
              "${APP_NAME}" \
              "${app_network}" \
              "${database_image}" \
              "${database_data_dir}" \
              "${database_user}" \
              "${database_container_name}" \
              "--detach" \
              "${database_command}"
            ;;

          --df | --dockerfile )
            Print_Text_With_Label "OPTION" "--df, --dockerfile" "4"

            dockerfile="${2? Missing variant for docker image... eg: alpine}"

            shift 2
            ;;

          --et | --elixir-tag )
            elixir_tag="${2? Missing Elixir tag!!!}"
            shift 2
            ;;

          -h | --help )
            shift 1

            if [ "${1:-}" = "stack" ]; then
              Show_Help
              exit 0
            fi

            run_command="elixir --help"
            ;;

          -it )
            background_mode="-it"
            shift 1
            ;;


          --no-cache )
            # not implemented yet
            ;;

          -p | --publish )
            port_map=${2? Missing host port map for the container, eg: 3000:3000 !!!}
            shift 2
            ;;

          --pv | --phoenix-version )
            phoenix_version="${2? Missing Phoenix version!!!}"
            shift 2
            ;;

          -u | --user )
            container_user=${2? Missing user for container!!!}
            shift 2
            ;;

          --verbose )
            shift 1

            VERBOSE_LEVEL=${1:-${VERBOSE_LEVEL}}

            if [ "$#" -ge 1 ]; then
              shift 1
            fi
            ;;

          build )
            Build_Docker_Image \
              "${image_name}" \
              "${2:-${dockerfile}}" \
              "${elixir_tag}" \
              "${phoenix_version}" \
              "${phoenix_install_from}" \
              "${build_path}"

            exit 0
            ;;

          container-logs )
            sudo docker logs -f "${app_container_name}"
            exit 0
            ;;

          down )
            Stop_And_Remove_Docker_Containers \
              "${app_container_name}" \
              "${database_container_name}"

            exit 0
            ;;

          iex | mix | pgcli )
            run_command=${1}
            shift 1
            ;;

          observer )
            shift 1

            # TODO:
            #  * observer_cli binary seems not be able to connect to the remote node
            #   frStart_Or_Attach_To_App_Container
            #  * https://chazsconi.github.io/2017/04/22/observing-remote-elixir-docker-nodes.html
            #run_command="observer_cli elixir@b09b4f769088 ${ERLANG_COOKIE}"

            Start_Observer_Container \
              "${host_setup_dir}" \
              "${APP_NAME}" \
              "${app_network}" \
              "${app_container_name}" \
              "${ERLANG_COOKIE}" \
              ${@}

            exit 0
            ;;

          up )
            Print_Text_With_Label "COMMAND" "up" "4"

            Start_Dummy_App_Container \
              "${image_name}" \
              "${elixir_tag}" \
              "${phoenix_version}" \
              "${dockerfile}" \
              "${APP_NAME}" \
              "${app_network}" \
              "${app_container_name}" \
              "${container_user}" \
              "${port_map}" \
              "${env_file}" \
              "${host_setup_dir}"

            shift 1

            local phoenix_command="${1:-${phoenix_command}}"

            if [ "$#" -ge 1 ]; then
              shift 1
            fi

            # we need to set the --cookie and -sname in order to be able to use the
            # Observer from another docker container in the same docker network.
            # The run command will execute inside the container:
            #   $ elixir --name video-hup_app@172.0.0.2 --cookie some-long-super-secret  -S mix phx.server"
            local run_command="elixir-server ${APP_NAME} ${ERLANG_COOKIE} ${phoenix_command}"
            ;;

          shell )
            Print_Text_With_Label "COMMAND" "Shell" "4"

            shift 1
            local run_command=${1:-zsh}

            if [ "$#" -ge 1 ]; then
              shift 1
            fi
            ;;

        esac
      done


    ############################################################################
    # EXECUTION
    ############################################################################

      Start_Or_Attach_To_App_Container \
        "${image_name}" \
        "${elixir_tag}" \
        "${phoenix_version}" \
        "${dockerfile}" \
        "${APP_NAME}" \
        "${app_network}" \
        "${app_container_name}" \
        "${container_user}" \
        "${port_map}" \
        "${env_file}" \
        "${background_mode}" \
        "${host_setup_dir}" \
        "${run_command}" \
        "${@}"
  }

Main "${@}"
