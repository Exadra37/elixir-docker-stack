#!/bin/bash

# @link https://elixir-lang.org/getting-started/debugging.html
# @link https://s3.us-east-2.amazonaws.com/ferd.erlang-in-anger/text.v1.1.0.pdf
# @link https://mfeckie.github.io/Remote-Profiling-Elixir-Over-SSH/
# @link https://github.com/ferd/recon

set -eu

Show_Help()
{
  cat << HEREDOC

ELIXIR DOCKER STACK

A docker developemnt stack that includes Elixir, Phoenix, Erlang, Oberver and Postgres.


ELIXIR CLI USAGE:

  elixir [options] [.exs file] [data]


ELIXIR DOCKER STACK USAGE:

  elixir [options] [command] [args]


ELIXIR DOCKER STACK OPTIONS:

  -d, --detached            Run the docker container detached from the terminal.

  --db, --database          Starts the container with the Postgres database up.

  --df, --dockerfile        The dockerfile to run a container.
                            Defaults to: debian
                              $ elixir --dockerfile alpine up
                              $ elixir --dockerfile debian.slim up

  --ev, --elixir-version    The Elixir version to be used for the docker tag,
                            Defaults to the latest Elixir version: 1.8
                              $ elixir --elixir-version 1.3.4 up

  -h, --help                Shows the help for the Elixir CLI and Stack.
                              $ elixir -h
                              $ elixir --help
                              $ elixir --help stack

  -it, --interactive-tty    Run the docker container attached to the terminal.
                              $ elixir -it up

  --mix-env                 Sets the MIX_ENV var in the container.
                            Defaults to dev.
                              $ mix --mix-env test ecto.create

  -p, --publish             Map the host ports to the docker container ports.
                            Defaults to: 4000:4000 .
                              $ elixir --publish 8000:4000 up

  --pv, --phoenix-version   The Phoenix version to be installed.
                            Defaults to the last release, eg: 1.4.3 .
                              $ elixir --phoenix-version 1.3.4 up

  -u, --user                The user we want to run inside the container,
                            Defaults to user, eg: elixir .
                              $ elixir --user root shell

  --verbose <level>         Enables verbose output for the docker stack.
                            Defaults to level 0, and can go until level 4.
                              $ elixir --verbose 1 up
                              $ elixir --verbose 2 shell
                              $ elixir --verbose 3 observer
                              $ elixir --verbose 4 build

  --wa, --wait-dummy-app    Seconds to wait for the app dummy container to be ready.
                            Defaults to 1 second.
                              $ elixir --wait-dummy-app 3 up

  --wd, --wait-database     Seconds to wait for the database is up and running.
                            Defaults to 5 seconds.
                              $ elixir --wait-database 10 new-database myapp_test


ELIXIR DOCKER STACK COMMANDS:

  <no-command>    Runs Elixir inside the container as it would in the host.
                    $ elixir --help

  build           Builds the docker image for the given dodkerfile.
                  Defaults to build from: debian .
                    $ elixir build
                    $ elixir build alpine

  container-logs  Shows a tail -f of the container logs.
                    $ elixir container-logs

  down            Stops and removes the running container.
                    $ elixir down

  iex             The Elixir IEx shell.
                    $ iex [options] <args>

  mix             The Elixir mix tool.
                    $ mix <command> [options] <args>
                    $ mix help
                    $ mix new elixir-project
                    $ mix phx.new phoenix-app

  new-database    Creates a new database.
                  Defaults to the current folder name with suffix "_dev".
                    $ elixir new-database
                    $ elixir new-database acme

  pgcli           A better shell for Postgres, includes auto-completion.
                    $ elixir pgcli [options] <args>

  observer        Starts the Observer GUI from an IEx shell.
                    $ elixir observer

  observer-cli    Allows to start from IEx the Observer CLI(like Linux HTOP).
                    $ elixir observer-cli

  up              Starts the Elixir docker stack.
                    $ elixir up
                    $ elixir --db up
                    $ elixir --dockerfile alpine up
                    $ elixir -it --publish 8000:4000 up
                    $ elixir --elixir-version 1.3 --phoenix-version 1.3.4 --db up

  shell           A shell inside the container for the Elixir docker stack.
                    $ elixir shell
                    $ elixir -u root shell

HEREDOC

}

################################################################################
# FUNCTIONS
################################################################################

  Print_Text_With_Label()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local label_text="${1? Missing label to print!!!}"

      local text="${2? Missing text to print!!!}"

      local verbosity_print_level="${3? Missing verbosity print level!!!}"

      local label_background_color="${4:-42}"

      local text_background_color="${5:-229}"


    ############################################################################
    # EXECUTION
    ############################################################################

      case "${verbosity_print_level}" in
        "1" )
          local label_background_color="40"
          ;;
        "2" )
          local label_background_color="44"
          ;;
        "3" )
          local label_background_color="45"
          ;;
        "4" )
          local label_background_color="46"
          ;;
        * )
          local label_background_color="42"
      esac

      if [ "${verbosity_print_level}" -le "${VERBOSE_LEVEL}" ]; then
        printf "\n\e[1;${label_background_color}m ${label_text}:\e[30;48;5;${text_background_color}m ${text} \e[0m \n"
      fi
  }

  Print_Text()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local text="${1? Missing text to print!!!}"

      local verbosity_print_level="${2? Missing verbosity print level!!!}"

      local text_color="${3:-44}"


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ "${verbosity_print_level}" -le "${VERBOSE_LEVEL}" ]; then
        printf "\n\e[1;${text_color}m ${text} \e[0m \n"
      fi
  }

  Print_Fatal_Error()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local text="${1? Missing text to print for the Fatal Error!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      printf "\n\e[1;41m FATAL ERROR:\e[30;48;5;229m ${text} \e[0m \n\n"
  }

  Create_Env_File_If_Not_Exists()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local suffix="${1:-.docker-container}"

      local example_suffix="${2:--example}"


    ############################################################################
    # EXECUTION
    ############################################################################

      # Useful to pass environment variables into the container.
      if [ ! -f .env"${suffix}" ]; then
        if [ -f .env"${suffix}${example_suffix}" ]; then
          cp .env"${suffix}${example_suffix}" .env"${suffix}"
        else
          touch .env"${suffix}"
        fi
      fi
  }

  # One Liner for testing in shell:
  #   → if sudo -h > /dev/null 2>&1 ; then echo 'Sudo is enabled.' ; else echo 'Sudo is not enabled' ; fi
  Sudo_Exists()
  {
    ############################################################################
    # EXECUTION
    ############################################################################

      if sudo -h > /dev/null 2>&1; then
        # sudo exists
        return 0
      fi

      # sudo doesn't exist
      return 1
  }

  Sudo_Prefix()
  {
    ############################################################################
    # EXECUTION
    ############################################################################

      if Sudo_Exists; then
        echo 'sudo'
        return
      fi

      echo ""
  }

  Setup_X11_Server_Display()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local host_setup_dir="${1? Missing host setup dir!!!}"

      local xauth_display="${2:-:0}"


    ############################################################################
    # VARS
    ############################################################################

      local xauth="${host_setup_dir}"/.docker.xauth


    ############################################################################
    # EXECUTION
    ############################################################################

      # @link http://wiki.ros.org/docker/Tutorials/GUI#The_isolated_way
      touch "${xauth}"
      xauth nlist "${xauth_display}" | sed -e 's/^..../ffff/' | xauth -f "${xauth}" nmerge -

      echo "${xauth}"
  }

  Is_Umbrella_App()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local path="${1? Missing path to check if is an umbrella app.!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ -f "${path}"/mix.exs ]; then
        grep -qw "apps_path:" "${path}"/mix.exs 2&> /dev/null
        return $?
      fi

      # Not an Umbrella App.
      return 1
  }

  Set_Global_Paths_For_Umbrella_App()
  {

    ############################################################################
    # EXECUTION
    ############################################################################

      if Is_Umbrella_App "${PWD}/.."; then
        APP_HOST_DIR="${PWD}/.."
        APP_CONTAINER_RELATIVE_PATH=workspace/apps
      fi

      if Is_Umbrella_App "${PWD}/../.."; then
        APP_HOST_DIR="${PWD}/../.."
        APP_CONTAINER_RELATIVE_PATH=workspace/apps/"${APP_NAME}"
      fi
  }

################################################################################
# DOCKER FUNCTIONS
################################################################################

  Is_App_With_Database()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local app_name="${1? Missing app name!!!}"

      local config_file=config/dev.exs

      if [ ! -f "${config_file}" ]; then
        local config_file="${app_name}/${config_file}"
      fi


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "Config file Path" "${config_file}" "3"

      # Converts `my_app_name` to `myappname` do that we can use a grep case
      # insensitive search on the string `MyAppName.Repo`.
      local repo_name="${app_name/_/}.Repo"
      Print_Text_With_Label "Repository Name" "${repo_name}" "3"

      grep -iq "${repo_name}," "${config_file}" 2&> /dev/null

      return $?
  }

  Is_Not_Present_Docker_Image()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local _image_name="${1}"

    ############################################################################
    # EXECUTION
    ############################################################################

      [ -z $( ${SUDO_PREFIX} docker images -q "${_image_name}" ) ] && return 0 || return 1
  }

  Get_Container_Ip_Address()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      echo -n $( ${SUDO_PREFIX} docker exec -it ${container_name} sh -c 'echo -n $(hostname -i)' )
  }

  Get_Container_Username_UID()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local docker_image="${1? Missing docker image!!!}"
      local user_name="${2? Missing user name to get the UID!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      echo -n $( ${SUDO_PREFIX} docker run --rm -it --user ${user_name} ${docker_image} sh -c 'echo -n $(id -u)' )
  }

  Get_Docker_Image_Tag()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local elixir_version="${1? Missing Elixir Version!!!}"

      local phoenix_version="${2? Missing Phoenix version!!!}"

      local dockerfile="${3? Missing variant for docker image!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ "${dockerfile}" = "observer-debian" ]; then
        echo "${elixir_version}"
      else
        echo "${elixir_version}_${phoenix_version}_${dockerfile}"
      fi
  }

  Create_Docker_Network_If_Not_Exists()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local network_name="${1? Missing network name!!!}"

    ############################################################################
    # EXECUTION
    ############################################################################

      ${SUDO_PREFIX} docker network create "${network_name}" &> /dev/null || true
  }

  Create_Docker_Volume()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "CREATING DOCKER VOLUME:" "${container_name}" "2"

      ${SUDO_PREFIX} docker volume create "${container_name}"
  }

  Build_Docker_Image()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local dockerfile="${2? Missing variant for docker image!!!}"

      local erlang_version="${3? Missing Erlang version!!!}"

      local elixir_version="${4? Missing Elixir version!!!}"

      local phoenix_version="${5? Missing Phoenix version!!!}"

      local mix_env="${6? Missing mix env value!!!}"

      local build_path="${7? Missing build path for docker image!!!}"

      shift 7


    ############################################################################
    # VARS
    ############################################################################

      if [ "${dockerfile}" = "observer-debian" ]; then

        local image_name=exadra37/observer

        local elixir_version=latest

      fi

      local tag="$( Get_Docker_Image_Tag "${elixir_version}" "${phoenix_version}" "${dockerfile}" )"

      local docker_image="${image_name}:${tag}"

      local dockerfile_path="${build_path}"/${dockerfile}".Dockerfile"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "DOCKER IMAGE" "${docker_image}" "1"

      Print_Text_With_Label "BUILDING FROM DOCKERFILE" "${dockerfile_path}" "2"

        # --no-cache \
        # --force-rm \
        # --pull \
      ${SUDO_PREFIX} docker build \
        --file "${dockerfile_path}" \
        --build-arg "DOCKER_ERLANG_VERSION=${erlang_version}" \
        --build-arg "DOCKER_ELIXIR_VERSION=${elixir_version}" \
        --build-arg "PHOENIX_VERSION=${phoenix_version}" \
        --build-arg "MIX_ENV=${mix_env}" \
        --tag ${docker_image} \
        "${build_path}"
  }

  Docker_Container_Is_Running()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local container_name="${1? Missing container name!!!}"


    ############################################################################
    # EXECUTION
    ############################################################################

      ${SUDO_PREFIX} docker container ls -a | grep -qw "${container_name}" -

      return $?
  }

  Attach_To_App_Container()
  {
    Print_Text_With_Label "FUNCTION" "Attach_To_App_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local app_container_name="${1? Missing app container name!!!}"

      local container_username="${2? Missing container userNAME!!!}"

      local background_mode="${3? Missing backround mode to run the container!!!}"

      local run_command="${4? Missing command to run in the container!!!}"

      shift 4

      local args="${@}"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "ATTACHING TO CONTAINER" "${app_container_name}" "1"

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${args}" "2"

      Print_Text_With_Label "BACKGROUND MODE" "${background_mode}" "3"

      APP_NODE_NAME="${APP_NAME}@$( Get_Container_Ip_Address ${app_container_name} )"

      ${SUDO_PREFIX} docker exec \
        --user ${container_username} \
        --env "APP_NODE_NAME=${APP_NODE_NAME}" \
        --env "APP_NODE_COOKIE=${ERLANG_COOKIE}" \
        ${background_mode} \
        ${app_container_name} \
        ${run_command} ${args}
  }

  Start_Or_Attach_To_App_Container()
  {
    Print_Text_With_Label "FUNCTION" "Start_Or_Attach_To_App_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local erlang_version="${2? Missing Erlang version!!!}"

      local elixir_version="${3? Missing Elixir version!!!}"

      local phoenix_version="${4? Missing Phoenix version!!!}"

      local dockerfile="${5? Missing docker image variant!!!}"

      local app_name="${6? Missing the APP name!!!}"

      local app_network="${7? Missing app network}"

      local app_container_name="${8? Missing app container name!!!}"

      local container_username="${9? Missing container userNAME!!!}"

      local port_map="${10? Missing port map!!!}"

      local mix_env="${11? Missing mix env value!!!}"

      local env_file="${12? Missing the env file!!!}"

      local background_mode="${13? Missing backround mode to run the container!!!}"

      local host_setup_dir="${14? Missing host dir for Elixir stack setup!!!}"

      local build_path="${15? Missing build path for docker image!!!}"

      local run_command="${16? Missing command to run in the container!!!}"

      shift 16

      local args="${@}"


    ############################################################################
    # VARS
    ############################################################################

      local tag="$( Get_Docker_Image_Tag "${elixir_version}" "${phoenix_version}" "${dockerfile}" )"

      local docker_image="${image_name}:${tag}"

      local xauth_sock="/tmp/.X11-unix"

      local xauth=$( Setup_X11_Server_Display "${host_setup_dir}" )

      local publish_ports=""

      if [ "${port_map}" != ":" ]; then
        local publish_ports="--publish 127.0.0.1:${port_map}"
      fi

      Set_Global_Paths_For_Umbrella_App

      Print_Text_With_Label "APP_HOST_DIR" "${APP_HOST_DIR}" "2"

      Print_Text_With_Label "APP_CONTAINER_RELATIVE_PATH" "${APP_CONTAINER_RELATIVE_PATH}" "2"


    ############################################################################
    # EXECUTION
    ############################################################################

      if Is_Not_Present_Docker_Image "${docker_image}"; then

        Print_Text_With_Label "DOCKER IMAGE" "${docker_image}" "0"

        Print_Text_With_Label "TAG" "${tag}" "0"

        Print_Text_With_Label "DOCKERFILE" "${dockerfile}" "0"

        Print_Text_With_Label "WARNING" "Missing docker image for >>> ${app_name} <<< APP. Please wait until we build the image." "1"

        Build_Docker_Image \
          "${image_name}" \
          "${dockerfile}" \
          "${erlang_version}" \
          "${elixir_version}" \
          "${phoenix_version}" \
          "${mix_env}" \
          "${build_path}"
      fi

      if Docker_Container_Is_Running "${app_container_name}"; then

        Attach_To_App_Container \
          "${app_container_name}" \
          "${container_username}" \
          "${background_mode}" \
          "${run_command}" \
          ${@}

        exit 0
      fi

      Print_Text_With_Label "STARTING DOCKER IMAGE" "${docker_image}" "1"

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${args}" "2"

      Print_Text_With_Label "DOCKERFILE" "${dockerfile}" "3"

      Print_Text_With_Label "TAG" "${tag}" "3"

      Print_Text_With_Label "CONTAINER USERNAME" "${container_username}" "3"

      Print_Text_With_Label "APP NETWORK" "${app_network}" "3"

      local env_file_option=""

      if [ -f "${env_file}" ]; then
          local env_file_option="--env-file ${env_file}"
      fi

      ${SUDO_PREFIX} docker run \
        --rm \
        ${background_mode} \
        ${env_file_option} \
        ${publish_ports} \
        ${CONTAINER_ENV} \
        --env "APP_NODE_NAME=${APP_NODE_NAME}" \
        --env "APP_NODE_COOKIE=${ERLANG_COOKIE}" \
        --env "MIX_ENV=${mix_env}" \
        --env "XAUTHORITY=${xauth}" \
        --name "${app_container_name}" \
        --hostname "${app_name}" \
        --user "${container_username}" \
        --network "${app_network}" \
        --workdir /home/"${container_username}/${APP_CONTAINER_RELATIVE_PATH}" \
        --volume "${APP_HOST_DIR}":/home/"${container_username}"/workspace \
        --volume "${app_container_name}_${tag}_var_lib_postgresql":/var/lib/postgresql \
        --volume "${app_container_name}_${tag}_var_log_postgresql":/var/log/postgresql \
        --volume "${app_container_name}_${tag}_config_sublimetext_3":/home/"${container_username}"/.config/sublime-text-3 \
        --volume "/tmp/.X11-unix":"/tmp/.X11-unix":ro \
        --volume "${xauth}":"${xauth}":ro \
        "${docker_image}" \
        ${run_command} ${args}
  }

  Start_Dummy_App_Container()
  {
    ############################################################################
    # INPUT
    ############################################################################

      local image_name="${1? Missing docker image name!!!}"

      local erlang_version="${2? Missing Erlang version!!!}"

      local elixir_version="${3? Missing Elixir version!!!}"

      local phoenix_version="${4? Missing Phoenix version!!!}"

      local dockerfile="${5? Missing docker image variant!!!}"

      local app_name="${6? Missing the APP name!!!}"

      local app_network="${7? Missing app network}"

      local app_container_name="${8? Missing app container name!!!}"

      local container_username="${9? Missing container userNAME!!!}"

      local port_map="${10? Missing port map!!!}"

      local mix_env="${11? Missing mix env value!!!}"

      local env_file="${12? Missing the env file!!!}"

      local host_setup_dir="${13? Missing host dir for Elixir stack setup!!!}"

      local build_path="${14? Missing build path for docker image!!!}"

      local seconds_to_wait_dummy_app_is_ready="${15? Missing seconds to wait until dummy app container is ready!!!}"

      shift 15


    ############################################################################
    # EXECUTION
    ############################################################################

      # We need a dummy Docker container running before we start any real
      # process on it, so that we can run Elixir or Phoenix apps with a full
      # qualified node name, byt getting the IP address of the dummy container.
      if ! Docker_Container_Is_Running "${app_container_name}"; then

        Print_Text "STARTING A DUMMY CONTAINER" "4"

        Start_Or_Attach_To_App_Container \
          "${image_name}" \
          "${erlang_version}" \
          "${elixir_version}" \
          "${phoenix_version}" \
          "${dockerfile}" \
          "${app_name}" \
          "${app_network}" \
          "${app_container_name}" \
          "${container_username}" \
          "${port_map}" \
          "${mix_env}" \
          "${env_file}" \
          "-td" \
          "${host_setup_dir}" \
          "${build_path}" \
          ""

          # need to give time for the container be available, before we try to
          # attach to it in the next command.
          sleep ${seconds_to_wait_dummy_app_is_ready}
    fi
  }

  Attach_To_Database_Container()
  {
    Print_Text_With_Label "FUNCTION" "Attach_To_Database_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local database_container_name="${1? Missing database container name!!!}"
      local database_user="${2? Missing database user!!!}"
      local run_command="${3? Missing command to run in the container!!!}"

      shift 3

      local args="${@}"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${args}" "2"

      if [ "${run_command}" = "postgres" ]; then
        Print_Text_With_Label "WARNING" "Postgres database is already running. You can only attach to run commands, eg: createdb ..." "1"
        return
      fi

      ${SUDO_PREFIX} docker exec \
        -it \
        --user "${database_user}" \
        "${database_container_name}" \
        ${run_command} ${args}
  }

  Start_Or_Attach_To_Database_Container()
  {
    Print_Text_With_Label "FUNCTION" "Start_Or_Attach_To_Database_Container" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local app_name="${1? Missing app name!!!}"

      local app_network="${2? Missing app network!!!}"

      local database_image="${3? Missing database image name!!!}"

      local database_data_dir="${4? Missing database data dir!!!}"

      local database_user="${5? Missing database user!!!}"

      local database_container_name="${6? Missing database container name!!!}"

      local background_mode="${7? Missing background mode to run the container!!!}"

      local run_command="${8? Missing command to run in the container!!!}"

      shift 8

      local args="${@}"


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "DATABASE CONTAINER" "${database_container_name}" "2"

      if [ ! -d "${database_data_dir}" ]; then

        Print_Text_With_Label "CHECK POINT" "Fixing database data dir permissions!!!" "4"

        local user_uid=$( Get_Container_Username_UID "${database_image}" "${database_user}" )

        Print_Text_With_Label "USER UID (${database_user})" "${user_uid}" "3"

        mkdir -p "${database_data_dir}"

        ${SUDO_PREFIX} chown -R ${user_uid}:${user_uid} "${database_data_dir}/.."
      fi

      if Docker_Container_Is_Running "${database_container_name}"; then

        Attach_To_Database_Container \
          "${database_container_name}" \
          "${database_user}" \
          ${run_command}

        return 0
      fi

      Print_Text_With_Label "INVOKED COMMAND" "${run_command} ${args}" "2"

      ${SUDO_PREFIX} docker run \
        --rm \
        "${background_mode}" \
        --hostname "${app_name}_database" \
        --user "${database_user}" \
        --name "${database_container_name}" \
        --network "${app_network}" \
        --volume "${database_data_dir}":/var/lib/postgresql/data \
        "${database_image}" ${run_command} ${args}
  }

  Run_Database_Command()
  {
    Print_Text_With_Label "FUNCTION" "Run_Database_Command" "4"

    ############################################################################
    # INPUT
    ############################################################################

      local app_name="${1? Missing app name!!!}"

      local app_network="${2? Missing app network!!!}"

      local database_image="${3? Missing database image name!!!}"

      local database_data_dir="${4? Missing database data dir!!!}"

      local database_user="${5? Missing database container userNAME!!!}"

      local database_container_name="${6? Missing database container name!!!}"

      local start_database_command="${7? Missing command to start database!!!}"

      local seconds_to_wait_database_is_running="${8? Missing seconds to wait database to be running!!!}"

      local run_command="${9? Missing command to run in the container!!!}"

      shift 9


    ############################################################################
    # EXECUTION
    ############################################################################

      Print_Text_With_Label "INVOKED COMMAND" "${run_command}" "4"

      if ! Docker_Container_Is_Running "${database_container_name}"; then

        Start_Or_Attach_To_Database_Container \
          "${app_name}" \
          "${app_network}" \
          "${database_image}" \
          "${database_data_dir}" \
          "${database_user}" \
          "${database_container_name}" \
          "--detach" \
          "${start_database_command}"

        Print_Text "Waiting for database engine to start..." "0"

        sleep ${seconds_to_wait_database_is_running}
      fi

      Start_Or_Attach_To_Database_Container \
        "${app_name}" \
        "${app_network}" \
        "${database_image}" \
        "${database_data_dir}" \
        "${database_user}" \
        "${database_container_name}" \
        "-it" \
        "${run_command}"
  }

  Start_Observer_Container()
  {
    # to implement over ssh tunnel:
    #   * https://sgeos.github.io/elixir/erlang/observer/2016/09/16/elixir_erlang_running_otp_observer_remotely.html
    #   * https://github.com/Stratus3D/dotfiles/blob/master/scripts/tools/epmd_port_forwarder
    #   * https://github.com/Nebo15/k8s-utils
    #   * https://chazsconi.github.io/2017/04/22/observing-remote-elixir-docker-nodes.html
    #
    # http://jbavari.github.io/blog/2016/03/11/using-erlang-observer-on-a-remote-elixir-server/

    ############################################################################
    # INPUT
    ############################################################################

      local host_setup_dir="${1? Missing host setup dir!!!}"

      local app_name="${2? Missing app name!!!}"

      local app_network="${3? Missing app network!!!}"

      local app_container_name="${4? Missing app container_name!!!}"

      local erlang_cookie="${5? Missing the Erlang cookie!!!}"

      local observer_container_username="${6? Missing Observer container userNAME!!!}"

      shift 6

      Print_Text_With_Label "HOST SETUP DIR" "${host_setup_dir}" "3"

      Print_Text_With_Label "APP NAME" "${app_name}" "3"

      Print_Text_With_Label "APP NETWORK" "${app_network}" "3"

      Print_Text_With_Label "APP CONTAINER NAME" "${app_container_name}" "3"

      Print_Text_With_Label "ERLANG COOKIE" "${erlang_cookie}" "3"

      if ! Docker_Container_Is_Running "${app_container_name}"; then
        Print_Fatal_Error "The App container >>> ${app_container_name} <<< is not running. Are you in the APP root folder?"
        return
      fi

      local app_ip_address=$( Get_Container_Ip_Address "${app_container_name}" )

      Print_Text_With_Label "APP IP ADDRESS" "${app_ip_address}" "3"

      case "${1:-}" in
        "htop" )
          local observer_command="observer-cli ${app_name} ${app_ip_address} ${erlang_cookie}"
          local observer_container_name="${app_name}_observer-htop"
          shift 1
          ;;

        "shell" )
          local observer_command="zsh"
          local observer_container_name="${app_name}_observer-shell"
          shift 1
          ;;

        "" )
          local observer_command="observer ${app_name} ${app_ip_address} ${erlang_cookie}"
          local observer_container_name="${app_name}_observer"
          ;;

        * )
          Print_Fatal_Error "Unsupported: ${input}"

      esac

    ############################################################################
    # CONSTANTS
    ############################################################################

      local OBSERVER_DOCKER_IMAGE="exadra37/observer"


    ############################################################################
    # EXECUTION
    ############################################################################

      if Is_Not_Present_Docker_Image "${OBSERVER_DOCKER_IMAGE}"; then

        Print_Text_With_Label "DOCKER IMAGE" "${OBSERVER_DOCKER_IMAGE}" "0"

        Print_Fatal_Error "Build first the docker image with: elixir build observer-debian"

        exit 1
      fi

      local xauth=$( Setup_X11_Server_Display "${host_setup_dir}" )

      Print_Text_With_Label "OBSERVER COMMAND" "${observer_command}" "2"

      ${SUDO_PREFIX} docker run \
        --rm \
        -it \
        --user "${observer_container_username}" \
        --hostname "${observer_container_name}" \
        --name "${observer_container_name}" \
        --network "${app_network}" \
        --volume="/tmp/.X11-unix":"/tmp/.X11-unix":ro \
        --volume="${xauth}":"${xauth}":ro \
        --env="XAUTHORITY=${xauth}" \
        "${OBSERVER_DOCKER_IMAGE}" ${observer_command} ${@}
  }

  Stop_And_Remove_Docker_Containers()
  {
    ############################################################################
    # EXECUTION
    ############################################################################

      for container_name in "${@}"; do

        if Docker_Container_Is_Running "${container_name}" ; then

          # no need to remove the containers explicitly, once they where started
          # with the `--rm` flag
          ${SUDO_PREFIX} docker stop "${container_name}"
        fi

      done
  }

################################################################################
# MAIN
################################################################################

  Main()
  {
    ############################################################################
    # CONSTANTS
    ############################################################################

      # from `/home/username/developer/acme` we will get `developer/acme`
      CURRENT_PATH="${PWD#*${USER}/}"
      # from `developer/acme` we get `developer_acme`
      #APP_NAME="${CURRENT_PATH//\//_}"

      APP_NAME="${PWD##*/}"

      APP_NODE_NAME=""

      ERLANG_COOKIE="super-long-secret-cookie"

      ELIXIR_DOCKER_STACK_INSTALL_DIR=${ELIXIR_DOCKER_STACK_INSTALL_DIR:-~/elixir-docker-stack}

      ELIXIR_DOCKER_STACK_DATA_DIR=${ELIXIR_DOCKER_STACK_DATA_DIR:-~/.elixir-docker-stack-data}

      SUDO_PREFIX=$(Sudo_Prefix)


    ############################################################################
    # ENV
    ############################################################################

      local image_name=exadra37/elixir-phoenix

      local dockerfile=debian

      local erlang_version=21.3.3

      local elixir_version=1.8

      local phoenix_version=1.4.3

      local phoenix_command=phx.server

      local build_path="${ELIXIR_DOCKER_STACK_INSTALL_DIR}"/docker/build

      local background_mode="-it"

      local app_port_map="4000:4000"

      local env_file=".env.app-docker-container"

      local database_image=postgres:11-alpine

      local database_user=postgres

      local database_command=postgres

      local seconds_to_wait_dummy_app_is_ready=1

      local seconds_to_wait_database_is_running=5

      local mix_env=dev

      local stack_defaults_file=.elixir-docker-stack-defaults

      # We can override any of the above variables in the .elixir-docker-stack-defaults
      # file in the home directory or from the root for the project we are
      # working on.
      #
      # Bear in mind that some can be override if provided as an argument or option
      # to this bash script.
      if [ -f ~/"${stack_defaults_file}" ]; then
        source ~/"${stack_defaults_file}"
      fi

      # It will override any variable already declared the ~/.env.elixir-docker-stack-defaults.
      #
      # Bear in mind that some can be override if provided as an argument or option
      # to this bash script.
      if [ -f "${stack_defaults_file}" ]; then
        source "${stack_defaults_file}"
      fi

      # from 1.4.0 assigns 1.4
      local phoenix_major_version="${phoenix_version%.*}"

      # Phoenix framework installation procedure changed from 1.4 onwards.
      if [ "${phoenix_major_version}" \< "1.4" ]; then
        phoenix_command=phoenix.server
      fi

      # from `developer/acme/my-app` we get `~/.elixir-docker-stack-data/developer_acme_my-app`
      local host_setup_dir="${ELIXIR_DOCKER_STACK_DATA_DIR}/${CURRENT_PATH//\//_}"

      local container_username=""

      local app_username=elixir

      local app_container_name="${APP_NAME}_app"

      local VERBOSE_LEVEL=0

      local app_network="${APP_NAME}_network"

      # by default it will be assigned $app_port_map when running commands:
      #   * up
      #   * phx.server, phoenix.server
      #   * phx.new, phoenix.new
      # we can override with -p or --publish
      #
      # ":" means no port map
      local port_map=":"

      local database_engine=postgres

      local database_data_dir="${host_setup_dir}"/${database_engine}/data

      local database_container_name="${APP_NAME}_${database_engine}"

      local observer_username=observer

      local APP_HOST_DIR="${PWD}"

      local APP_CONTAINER_RELATIVE_PATH=workspace

      local CONTAINER_ENV=""


    ############################################################################
    # PARSE INPUT / EXECUTION
    ############################################################################

      mkdir -p "${host_setup_dir}"

      Create_Docker_Network_If_Not_Exists "${app_network}"

      local run_command=${0##*/}

      for input in "${@}"; do
        case "${input}" in

          -d | --detach )
            Print_Text_With_Label "OPTION" "-d, --detach" "4"

            background_mode="--detach"
            shift 1
          ;;

          --db | --database )
            Print_Text_With_Label "OPTION" "--db, --database" "4"

            shift 1

            Start_Or_Attach_To_Database_Container \
              "${APP_NAME}" \
              "${app_network}" \
              "${database_image}" \
              "${database_data_dir}" \
              "${database_user}" \
              "${database_container_name}" \
              "--detach" \
              "${database_command}"
          ;;

          --db-image | --database-image )
            Print_Text_With_Label "OPTION" "--df, --dockerfile" "4"

            local database_image="${2? Missing database image to use!!!}"
            shift 2
          ;;

          --df | --dockerfile )
            Print_Text_With_Label "OPTION" "--df, --dockerfile" "4"

            local dockerfile="${2? Missing variant for docker image... eg: alpine}"

            shift 2
          ;;

          -e | --env )

            local CONTAINER_ENV="${CONTAINER_ENV} --env ${2? Missing env variable !!!}"
            shift 2
          ;;

          --ev | --elixir-version )
            Print_Text_With_Label "OPTION" "--ev, --elixir-version" "4"

            local elixir_version="${2? Missing Elixir version!!!}"
            shift 2
          ;;

          -h | --help )
            Print_Text_With_Label "OPTION" "-h, --help" "4"

            shift 1

            if [ "${1:-}" = "stack" ]; then
              Show_Help
              exit 0
            fi

            local run_command="elixir --help"
          ;;

          -it )
            Print_Text_With_Label "OPTION" "-it" "4"

            local background_mode="-it"
            shift 1
          ;;

          --mix-env )
            Print_Text_With_Label "OPTION" "--mix-env" "4"

            local mix_env="${2? Missing mix env value. One of dev,prod or test!!!}"
          ;;

          --no-cache )
            # not implemented yet
          ;;

          -p | --publish )
            Print_Text_With_Label "OPTION" "-p, --publish" "4"

            local port_map=${2? Missing host port map for the container, eg: 3000:3000 !!!}
            shift 2
          ;;

          --pv | --phoenix-version )
            Print_Text_With_Label "OPTION" "--pv, --phoenix-version" "4"

            local phoenix_version="${2? Missing Phoenix version!!!}"
            shift 2
          ;;

          -u | --user )
            Print_Text_With_Label "OPTION" "-u, --user" "4"

            local container_username=${2? Missing user for container!!!}
            shift 2
          ;;

          --verbose )
            Print_Text_With_Label "OPTION" "--verbose" "4"

            shift 1

            local VERBOSE_LEVEL=${1:-${VERBOSE_LEVEL}}

            if [ "$#" -ge 1 ]; then
              shift 1
            fi
          ;;

          --wa | --wait-dummy-app )
            Print_Text_With_Label "OPTION" "--wa, --wait-dummy-app" "4"

            local seconds_to_wait_dummy_app_is_ready="${2? Missing seconds to wait for dummy app container to be ready!!!}"
            shift 2
          ;;

          --wd | --wait-database )
            Print_Text_With_Label "OPTION" "--wd, --wait-database" "4"

            local seconds_to_wait_database_is_running="${2? Missing seconds to wait for the database to be running!!!}"
            shift 2
          ;;

          build )
            Print_Text_With_Label "COMMAND" "build" "4"

            Build_Docker_Image \
              "${image_name}" \
              "${2:-${dockerfile}}" \
              "${erlang_version}" \
              "${elixir_version}" \
              "${phoenix_version}" \
              "${mix_env}" \
              "${build_path}"

            exit 0
          ;;

          container-logs )
            Print_Text_With_Label "COMMAND" "container-logs" "4"

            ${SUDO_PREFIX} docker logs -f "${app_container_name}"
            exit 0
          ;;

          down )
            Print_Text_With_Label "COMMAND" "down" "4"

            Stop_And_Remove_Docker_Containers \
              "${app_container_name}" \
              "${database_container_name}"

            exit 0
          ;;

          new-database )
            Print_Text_With_Label "COMMAND" "new-database" "4"

            shift 1
            local database_name="${1:-${APP_NAME}_dev}"

            if [ "$#" -ge 1 ]; then
              shift 1
            fi

            Run_Database_Command \
              "${APP_NAME}" \
              "${app_network}" \
              "${database_image}" \
              "${database_data_dir}" \
              "${database_user}" \
              "${database_container_name}" \
              "${database_command}" \
              "${seconds_to_wait_database_is_running}" \
              "createdb -O postgres -U postgres ${database_name}"

            exit 0
          ;;

          observer )
            Print_Text_With_Label "COMMAND" "observer" "4"

            shift 1

            if [ -z "${container_username}" ]; then
              local container_username="${observer_username}"
            fi

            # TODO:
            #  * observer_cli binary seems not be able to connect to the remote node
            #   frStart_Or_Attach_To_App_Container
            #  * https://chazsconi.github.io/2017/04/22/observing-remote-elixir-docker-nodes.html
            #run_command="observer_cli elixir@b09b4f769088 ${ERLANG_COOKIE}"

            Start_Observer_Container \
              "${host_setup_dir}" \
              "${APP_NAME}" \
              "${app_network}" \
              "${app_container_name}" \
              "${ERLANG_COOKIE}" \
              "${container_username}" \
              ${@}

            exit 0
          ;;

          pgcli )
            Print_Text_With_Label "COMMAND" "pgcli" "4"

            run_command=${1}
            shift 1

            break
          ;;

          new | phoenix.new | phx.new )
            Print_Text_With_Label "COMMAND" "${1}" "4"

            # break parsing the input if --version option is given.
            case "${2:-}" in
              --version )
                break
              ;;
            esac

            local new_app_name="${2? Missing path to create the new app!!!}"

            local new_app_network="${new_app_name}_network"

            local database_hostname="${new_app_name}_postgres"

            local database_data_dir="${host_setup_dir}_${new_app_name}/${database_engine}/data"

            if [ "${port_map}" = ":" ]; then
              local port_map="${app_port_map}"
            fi

            if [ -z "${container_username}" ]; then
              local container_username="${app_username}"
            fi

            Start_Or_Attach_To_App_Container \
              "${image_name}" \
              "${erlang_version}" \
              "${elixir_version}" \
              "${phoenix_version}" \
              "${dockerfile}" \
              "${APP_NAME}" \
              "${app_network}" \
              "${app_container_name}" \
              "${container_username}" \
              "${port_map}" \
              "${mix_env}" \
              "${env_file}" \
              "${background_mode}" \
              "${host_setup_dir}" \
              "${build_path}" \
              "${run_command}" \
              ${@}

            # Pinning defaults to be used each time we run the Elixir Docker Stack
            echo "elixir_version=${elixir_version}" > "${new_app_name}/${stack_defaults_file}"
            echo "dockerfile=${dockerfile}" >> "${new_app_name}/${stack_defaults_file}"

            case "${1:-}" in
              phx.new | phoenix.new )
                echo "phoenix_version=${phoenix_version}" >> "${new_app_name}/${stack_defaults_file}"
                echo "phoenix_command=${phoenix_command}" >> "${new_app_name}/${stack_defaults_file}"
              ;;
            esac

            Create_Docker_Network_If_Not_Exists "${new_app_network}"
            ${SUDO_PREFIX} docker network rm "${app_network}"

            if Is_App_With_Database "${new_app_name}"; then

              # Pinning defaults to be used each time we run the Elixir Docker Stack
              echo "database_image=${database_image}" >> "${new_app_name}/${stack_defaults_file}"
              echo "database_user=${database_user}" >> "${new_app_name}/${stack_defaults_file}"
              echo "database_data_dir=${database_data_dir}" >> "${new_app_name}/${stack_defaults_file}"
              echo "database_command=${database_command}" >> "${new_app_name}/${stack_defaults_file}"

              # Fix the database hostname in the APp configuration file.
              sed -i -e "s/hostname: \"localhost\"/hostname: \"${database_hostname}\"/g" ${new_app_name}/config/dev.exs

              Start_Or_Attach_To_Database_Container \
                "${new_app_name}" \
                "${new_app_network}" \
                "${database_image}" \
                "${database_data_dir}" \
                "${database_user}" \
                "${new_app_name}_${database_engine}" \
                "--detach" \
                "${database_command}"
            fi

            exit 0
          ;;

          phx.server | phoenix.server )
            Print_Text_With_Label "COMMAND" "phx.server, phoenix.server" "4"

            if [ "${port_map}" = ":" ]; then
              local port_map="${app_port_map}"
            fi
          ;;

          up )
            Print_Text_With_Label "COMMAND" "up" "4"

            shift 1

            if Is_App_With_Database "${APP_NAME}"; then

              Start_Or_Attach_To_Database_Container \
                "${APP_NAME}" \
                "${app_network}" \
                "${database_image}" \
                "${database_data_dir}" \
                "${database_user}" \
                "${database_container_name}" \
                "--detach" \
                "${database_command}"
            fi

            if [ "${port_map}" = ":" ]; then
              local port_map="${app_port_map}"
            fi

            if [ -z "${container_username}" ]; then
              local container_username="${app_username}"
            fi

            Start_Dummy_App_Container \
              "${image_name}" \
              "${erlang_version}" \
              "${elixir_version}" \
              "${phoenix_version}" \
              "${dockerfile}" \
              "${APP_NAME}" \
              "${app_network}" \
              "${app_container_name}" \
              "${container_username}" \
              "${port_map}" \
              "${mix_env}" \
              "${env_file}" \
              "${host_setup_dir}" \
              "${build_path}" \
              "${seconds_to_wait_dummy_app_is_ready}"


            local phoenix_command="${1:-${phoenix_command}}"

            if [ "$#" -ge 1 ]; then
              shift 1
            fi

            # we need to set the --cookie and -sname in order to be able to use the
            # Observer from another docker container in the same docker network.
            # The run command will execute inside the container:
            #   $ elixir --name video-hup_app@172.0.0.2 --cookie some-long-super-secret  -S mix phx.server"
            local run_command="elixir-server ${APP_NAME} ${ERLANG_COOKIE} ${phoenix_command}"

            break
          ;;

          shell )
            Print_Text_With_Label "COMMAND" "Shell" "4"

            shift 1

            local run_command=${1:-zsh}

            if [ "$#" -ge 1 ]; then
              shift 1
            fi

            break
          ;;

        esac
      done


    ############################################################################
    # EXECUTION
    ############################################################################

      if [ -z "${container_username}" ]; then
        local container_username="${app_username}"
      fi

      Start_Or_Attach_To_App_Container \
        "${image_name}" \
        "${erlang_version}" \
        "${elixir_version}" \
        "${phoenix_version}" \
        "${dockerfile}" \
        "${APP_NAME}" \
        "${app_network}" \
        "${app_container_name}" \
        "${container_username}" \
        "${port_map}" \
        "${mix_env}" \
        "${env_file}" \
        "${background_mode}" \
        "${host_setup_dir}" \
        "${build_path}" \
        "${run_command}" \
        ${@}
  }

Main "${@}"
